# 常见的设计模式

## 单例设计模式

### 介绍

单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。

### 作用

1. **控制实例数量**：确保一个类只有一个实例存在
2. **全局访问**：提供一个全局访问点，方便其他对象访问该实例
3. **节省资源**：避免频繁创建和销毁对象，减少系统资源开销

### 适用场景

1. 需要频繁创建和销毁的对象
2. 创建对象时耗时过多或耗资源过多，但又经常用到的对象
3. 工具类对象（如日志工具、配置工具等）
4. 需要共享访问或控制共享资源的场景（如数据库连接池、线程池等）

### 实现方式

1. **饿汉式单例**（线程安全）

```java
public class EagerSingleton {
    // 类加载时就初始化实例，保证线程安全
    private static final EagerSingleton instance = new EagerSingleton();
    
    // 私有构造函数，防止外部实例化
    private EagerSingleton() {}
    
    // 提供全局访问点
    public static EagerSingleton getInstance() {
        return instance;
    }
}
```

**特点**：线程安全，实现简单，但可能造成资源浪费（如果实例未被使用）

2. **懒汉式单例**（线程安全 - 双重检查锁）

```java
public class LazySingleton {
    // 使用volatile防止指令重排序
    private static volatile LazySingleton instance;
    
    private LazySingleton() {} // 私有构造
    
    public static LazySingleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (LazySingleton.class) { // 加锁
                if (instance == null) { // 第二次检查
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
```

**特点**：线程安全，延迟加载，性能较好

3. **静态内部类实现**（线程安全，推荐）

```java
public class Singleton {
    private Singleton() {} // 私有构造
    
    // 静态内部类在第一次使用时加载
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**特点**：线程安全，延迟加载，实现简单，无需同步锁

4. **枚举实现**（线程安全，防反射攻击）

```java
public enum EnumSingleton {
    INSTANCE;
    
    public void doSomething() {
        // 业务方法
    }
}
// 使用：EnumSingleton.INSTANCE.doSomething();
```

**特点**：线程安全，防止反射和反序列化创建新实例，实现最简单

### 多线程注意事项

1. **可见性问题**：使用`volatile`关键字确保多线程环境下的可见性
2. **指令重排序**：使用`volatile`防止new操作时的指令重排序
3. **同步性能**：使用双重检查锁或静态内部类避免不必要的同步开销
4. **反射攻击**：在构造函数中添加检查防止通过反射创建新实例

#### 推荐使用

- **简单场景**：枚举实现或饿汉式
- **需要延迟加载**：静态内部类实现
- **高性能要求**：双重检查锁实现

这样的实现方式确保了在多线程环境下单例模式的安全性和性能。

## 适配器设计模式

### 介绍

适配器模式（Adapter Pattern）是一种结构型设计模式，它允许不兼容的接口之间能够协同工作。就像现实中的电源适配器可以让不同插头的电器使用同一插座一样

### 作用

1. **接口转换**：将一个类的接口转换成客户希望的另一个接口
2. **兼容性**：使原本因接口不兼容而不能一起工作的类可以一起工作
3. **复用性**：让现有的类能够被复用而不需要修改其源代码

### 场景

1. 需要使用现有的类，但其接口与需要的接口不匹配时
2. 想要创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作
3. 需要统一多个不同子系统的接口时

### 示例代码

* **场景描述**

  假设我们有一个旧的MP3播放器只能播放MP3格式，但现在有一个新的音频播放系统只能接收MP4格式。我们需要一个适配器让旧的MP3播放器能在新系统中工作

  ```java
  // 1. 旧系统接口 - MP3播放器
  interface OldMp3Player {
      void playMp3(String fileName);
  }
  
  // 2. 旧系统实现
  class MyMp3Player implements OldMp3Player {
      public void playMp3(String fileName) {
          System.out.println("播放MP3文件: " + fileName);
      }
  }
  
  // 3. 新系统接口 - 只能播放MP4
  interface NewPlayer {
      void playMp4(String fileName);
  }
  
  // 4. 适配器 - 让MP3播放器也能"播放"MP4
  class PlayerAdapter implements NewPlayer {
      private OldMp3Player oldPlayer;
      
      public PlayerAdapter(OldMp3Player player) {
          this.oldPlayer = player;
      }
      
      public void playMp4(String fileName) {
          // 将MP4文件转换为MP3文件名（简单模拟转换过程）
          String mp3File = fileName.replace(".mp4", ".mp3");
          System.out.println("转换MP4到MP3: " + fileName + " -> " + mp3File);
          oldPlayer.playMp3(mp3File);
      }
  }
  
  // 使用示例
  public class AdapterDemo {
      public static void main(String[] args) {
          // 旧的MP3播放器
          OldMp3Player oldPlayer = new MyMp3Player();
          
          // 适配器
          NewPlayer adapter = new PlayerAdapter(oldPlayer);
          
          // 新系统调用适配器播放MP4
          adapter.playMp4("song.mp4");
      }
  }
  ```
  
* **输出结果**

  ```txt
  转换MP4到MP3: song.mp4 -> song.mp3
  播放MP3文件: song.mp3
  ```
  
  

## 责任链设计模式

### 介绍

责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止

### 作用

1. **解耦**：将请求的发送者和接收者解耦
2. **灵活性**：可以动态地改变处理请求的对象和顺序
3. **可扩展**：可以方便地新增处理者

### 场景

1. 有多个对象可以处理同一个请求，但具体由哪个对象处理在运行时自动确定
2. 想在不明确指定接收者的情况下，向多个对象中的一个提交请求
3. 需要动态指定一组对象处理请求

### 示例代码

- **场景描述**
	假设我们有一个审批系统，不同级别的领导有不同的审批权限：
    - 组长：能审批≤1天的请假
    - 经理：能审批≤3天的请假
    - 总监：能审批≤7天的请假
    - 超过7天需要董事会审批

    ```java
    Java// 1. 抽象处理者
    abstract class Leader {
        protected Leader next; // 下一个处理者
	
        public void setNext(Leader next) {
            this.next = next;
        }
	
        public abstract void handleRequest(int leaveDays);
    }
	
    // 2. 具体处理者 - 组长
    class GroupLeader extends Leader {
        public void handleRequest(int leaveDays) {
            if (leaveDays <= 1) {
                System.out.println("组长批准了" + leaveDays + "天假期");
            } else if (next != null) {
                next.handleRequest(leaveDays);
            }
        }
    }
	
    // 3. 具体处理者 - 经理
    class Manager extends Leader {
        public void handleRequest(int leaveDays) {
            if (leaveDays <= 3) {
                System.out.println("经理批准了" + leaveDays + "天假期");
            } else if (next != null) {
                next.handleRequest(leaveDays);
            }
        }
    }
	
    // 4. 具体处理者 - 总监
    class Director extends Leader {
        public void handleRequest(int leaveDays) {
            if (leaveDays <= 7) {
                System.out.println("总监批准了" + leaveDays + "天假期");
            } else {
                System.out.println(leaveDays + "天假期需要董事会审批");
            }
        }
    }
	
    // 使用示例
    public class ChainDemo {
        public static void main(String[] args) {
            // 创建责任链
            Leader groupLeader = new GroupLeader();
            Leader manager = new Manager();
            Leader director = new Director();
	
            // 设置责任链顺序
            groupLeader.setNext(manager);
            manager.setNext(director);
	
            // 测试不同天数的审批
            groupLeader.handleRequest(1);   // 组长审批
            groupLeader.handleRequest(2);   // 经理审批
            groupLeader.handleRequest(5);   // 总监审批
            groupLeader.handleRequest(10);  // 董事会审批
        }
    }
    ```

- **输出结果**  

  ```
    组长批准了1天假期
    经理批准了2天假期
    总监批准了5天假期
    10天假期需要董事会审批
  ```
  
- **代码解析**

    1. **Leader**：抽象处理者，定义处理请求的接口和设置下一个处理者的方法
    2. **GroupLeader/Manager/Director**：具体处理者，实现处理请求的具体逻辑，如果不能处理则传递给下一个处理者
    3. **ChainDemo**：客户端代码，构建责任链并发送请求

    这个例子展示了请求如何沿着责任链传递，直到找到合适的处理者。每个处理者只需关注自己能处理的请求，不需要知道整个链的结构



## 策略设计模式

### 介绍

策略模式是一种行为型设计模式，它定义了一系列算法，并将每个算法封装起来，使它们可以互相替换。策略模式让算法的变化独立于使用算法的客户端

### 作用

1. **算法封装**：将每个算法封装成独立的策略类
2. **灵活替换**：可以在运行时动态切换算法
3. **消除条件判断**：避免使用大量的if-else或switch-case语句

### 场景

1. 一个系统需要动态地在几种算法中选择一种时
2. 有多个条件分支的相同行为时
3. 不希望暴露复杂的、与算法相关的数据结构时

### 示例代码

* **场景描述**

  支付方式选择

  ```java
  // 1. 策略接口（定义算法族）
  interface PaymentStrategy {
      void pay(int amount);
  }
  
  // 2. 具体策略实现
  class CreditCardPayment implements PaymentStrategy {
      public void pay(int amount) {
          System.out.println("使用信用卡支付：" + amount + "元");
      }
  }
  
  class AlipayPayment implements PaymentStrategy {
      public void pay(int amount) {
          System.out.println("使用支付宝支付：" + amount + "元");
      }
  }
  
  class WechatPayment implements PaymentStrategy {
      public void pay(int amount) {
          System.out.println("使用微信支付：" + amount + "元");
      }
  }
  
  // 3. 上下文类（使用策略）
  class PaymentContext {
      private PaymentStrategy strategy;
      
      public void setStrategy(PaymentStrategy strategy) {
          this.strategy = strategy;
      }
      
      public void executePayment(int amount) {
          strategy.pay(amount);
      }
  }
  
  // 4. 客户端使用
  public class StrategyDemo {
      public static void main(String[] args) {
          PaymentContext context = new PaymentContext();
          
          // 使用信用卡支付
          context.setStrategy(new CreditCardPayment());
          context.executePayment(100);
          
          // 切换为支付宝支付
          context.setStrategy(new AlipayPayment());
          context.executePayment(200);
          
          // 切换为微信支付
          context.setStrategy(new WechatPayment());
          context.executePayment(300);
      }
  }
  ```
  
  **策略模式 vs if-else 实现对比**

  ```java
  void pay(String type, int amount) {
      if ("credit".equals(type)) {
          System.out.println("信用卡支付：" + amount);
      } else if ("alipay".equals(type)) {
          System.out.println("支付宝支付：" + amount);
      } else if ("wechat".equals(type)) {
          System.out.println("微信支付：" + amount);
      }
      // 新增支付方式需要修改此方法
  }
  ```
  
* 输出结果

  ```
  使用信用卡支付：100元
  使用支付宝支付：200元
  使用微信支付：300元
  ```
  
* 代码解析

  1. **PaymentStrategy**：策略接口，定义支付算法的通用接口
  2. **具体支付类**：实现具体的支付算法（信用卡/支付宝/微信）
  3. **PaymentContext**：持有一个策略引用，负责调用具体策略
  4. **客户端**：创建上下文对象，设置具体策略并执行

## 适配器设计模式

### 介绍

适配器模式（Adapter Pattern）是一种结构型设计模式，主要用于解决两个已有组件之间接口不兼容的问题。该模式通过创建一个中间适配层，使得原本无法协同工作的类能够一起工作，而无需修改它们的源代码。

### 作用

1. **接口转换**：将源接口转换为目标接口
2. **兼容适配**：解决新旧系统/组件之间的兼容性问题
3. **代码复用**：使现有代码能够在不修改的情况下被新系统使用

### 场景

1. 系统需要使用现有类，但这些类的接口不符合系统要求
2. 需要创建可复用的类，用于与不相关或不可预见的类协同工作
3. 多个子系统需要统一接口时

### 代码示例

**场景描述**

现有遗留系统使用MP3播放接口，新系统要求使用MP4播放接口。需要创建适配器使旧系统能够在新环境中工作。

```java
// 旧系统接口
interface Mp3Player {
void playMp3(String fileName);
}

// 旧系统实现
class LegacyPlayer implements Mp3Player {
@Override
public void playMp3(String fileName) {
System.out.println("Playing MP3 file: " + fileName);
}
}

// 新系统要求接口
interface AdvancedPlayer {
void playMp4(String fileName);
}

// 对象适配器实现
class PlayerAdapter implements AdvancedPlayer {
private Mp3Player mp3Player;

public PlayerAdapter(Mp3Player player) {
this.mp3Player = player;
}

@Override
public void playMp4(String fileName) {
// 转换逻辑
String mp3FileName = fileName.replace(".mp4", ".mp3");
System.out.println("Converting MP4 to MP3: " + fileName);
mp3Player.playMp3(mp3FileName);
}
}

// 客户端使用
public class Client {
public static void main(String[] args) {
// 旧系统组件
Mp3Player oldPlayer = new LegacyPlayer();

// 创建适配器
AdvancedPlayer adapter = new PlayerAdapter(oldPlayer);

// 新系统调用
adapter.playMp4("music.mp4");
}
}
```

## 装饰器设计模式

### 介绍

装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

### 作用

1. **动态扩展**：动态地给一个对象添加一些额外的职责
2. **替代继承**：通过组合而非继承的方式扩展功能，更加灵活
3. **避免子类膨胀**：不需要通过继承增加子类就能扩展功能
4. **符合开闭原则**：对扩展开放，对修改关闭

### 场景

1. 需要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
2. 需要扩展一个类的功能，但使用继承会导致子类膨胀
3. 需要为对象添加的功能可能在未来会被撤销

### 示例代码

**场景描述：**

给奶茶加料

- 基础奶茶：10元
  - 珍珠：+2元
  - 奶盖：+3元
- 可以随意组合，不影响基础奶茶

```java
// 基础接口
interface MilkTea {
    double getCost();
    String getDescription();
}

// 基础奶茶
class BasicMilkTea implements MilkTea {
    public double getCost() { return 10.0; }
    public String getDescription() { return "基础奶茶"; }
}

// 装饰器基类
abstract class ToppingDecorator implements MilkTea {
    protected MilkTea milkTea;
    
    public ToppingDecorator(MilkTea milkTea) {
        this.milkTea = milkTea;
    }
}

// 具体装饰器：珍珠
class Pearl extends ToppingDecorator {
    public Pearl(MilkTea milkTea) { super(milkTea); }
    
    public double getCost() { return milkTea.getCost() + 2.0; }
    public String getDescription() { 
        return milkTea.getDescription() + " + 珍珠"; 
    }
}

// 具体装饰器：奶盖
class CheeseFoam extends ToppingDecorator {
    public CheeseFoam(MilkTea milkTea) { super(milkTea); }
    
    public double getCost() { return milkTea.getCost() + 3.0; }
    public String getDescription() { 
        return milkTea.getDescription() + " + 奶盖"; 
    }
}

// 使用：随意组合
public class Main {
    public static void main(String[] args) {
        MilkTea myDrink = new BasicMilkTea();
        myDrink = new Pearl(myDrink);      // 加珍珠
        myDrink = new CheeseFoam(myDrink); // 加奶盖
        
        System.out.println(myDrink.getDescription() + ", 价格: " + myDrink.getCost() + "元");
        // 输出：基础奶茶 + 珍珠 + 奶盖, 价格: 15.0元
    }
}
```

## 组合设计模式

### 介绍

组合模式（Composite Pattern）是一种**结构型设计模式**，它允许你将对象组合成**树形结构**来表示“部分-整体”的层次关系。组合模式使得客户端可以**统一处理单个对象和组合对象**，无需关心具体是哪种类型。

### 作用
1. **简化客户端代码**：客户端可以一致地处理单个对象和组合对象。
2. **表示层次结构**：适合表示树形结构（如文件系统、组织架构等）。
3. **灵活扩展**：可以方便地增加新的组件类型。

### 场景
- 需要表示**部分-整体**的层次结构（如公司组织架构、文件目录）。
- 希望客户端忽略组合对象与单个对象的差异，统一使用。

### 示例代码

**场景描述**

假设公司有**部门**和**员工**两种角色，部门可以包含员工或其他子部门，形成一个树形结构。

```java
import java.util.ArrayList;
import java.util.List;

// 1. 定义组件接口（抽象类）
interface OrganizationComponent {
    void display(); // 展示组织信息
    void add(OrganizationComponent component); // 添加子组件（部门或员工）
}

// 2. 叶子节点（员工）
class Employee implements OrganizationComponent {
    private String name;
    private String position;

    public Employee(String name, String position) {
        this.name = name;
        this.position = position;
    }

    @Override
    public void display() {
        System.out.println("员工: " + name + ", 职位: " + position);
    }

    @Override
    public void add(OrganizationComponent component) {
        throw new UnsupportedOperationException("员工不能添加子节点");
    }
}

// 3. 组合节点（部门）
class Department implements OrganizationComponent {
    private String name;
    private List < OrganizationComponent > children = new ArrayList < > ();

    public Department(String name) {
        this.name = name;
    }

    @Override
    public void display() {
        System.out.println("部门: " + name);
        for (OrganizationComponent component: children) {
            component.display(); // 递归调用子组件的display()
        }
    }

    @Override
    public void add(OrganizationComponent component) {
        children.add(component);
    }
}

// 4. 客户端使用
public class CompositePatternDemo {
    public static void main(String[] args) {
        // 创建员工
        OrganizationComponent emp1 = new Employee("张三", "开发工程师");
        OrganizationComponent emp2 = new Employee("李四", "测试工程师");

        // 创建子部门
        Department devDepartment = new Department("开发部");
        devDepartment.add(emp1);

        Department testDepartment = new Department("测试部");
        testDepartment.add(emp2);

        // 创建根部门
        Department company = new Department("某公司");
        company.add(devDepartment);
        company.add(testDepartment);

        // 展示整个组织架构
        company.display();
    }
}
```

**输出结果**：
```
部门: 某公司
部门: 开发部
员工: 张三, 职位: 开发工程师
部门: 测试部
员工: 李四, 职位: 测试工程师
```

**组合模式的特征：**

1. **统一的组件接口**：所有节点（叶子节点和组合节点）实现同一个接口或抽象类。
2. **递归组合**：组合节点可以包含其他组合节点或叶子节点，形成树形结构。
3. **透明性**：客户端无需区分叶子节点和组合节点，调用方法一致（如`add()`和`display()`）。
4. **叶子节点限制**：叶子节点（如`Employee`）的`add()`方法通常抛出异常或空实现。

# 优秀的设计模式博客

[小浣熊-设计模式网站](https://refactoringguru.cn/)

[重学设计模式](https://github.com/fuzhengwei/itstack-demo-design)





















