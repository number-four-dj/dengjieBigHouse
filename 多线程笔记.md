# 多线程笔记

## 线程池的四种拒绝策略

下面我将给出线程池四种拒绝策略的完整示例代码，每个策略一个独立示例，方便对比理解。

### 1. AbortPolicy 示例（默认策略）

```java
import java.util.concurrent.*;

public class AbortPolicyDemo {
    public static void main(String[] args) {
        // 创建线程池：核心2线程，最大2线程，队列容量2
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2, 2, 0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(2),
                new ThreadPoolExecutor.AbortPolicy()); // 拒绝时抛出异常

        try {
            // 提交5个任务（超过容量）
            for (int i = 1; i <= 5; i++) {
                final int taskId = i;
                executor.execute(() -> {
                    try {
                        System.out.println("执行任务" + taskId + " 线程: " +
                                Thread.currentThread().getName());
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
                System.out.println("提交任务" + taskId);
            }
        } catch (RejectedExecutionException e) {
            System.err.println("任务被拒绝: " + e.getMessage());
        } finally {
            executor.shutdown();
        }
    }
}
```

**输出特点**：提交第 5 个任务时会抛出 RejectedExecutionException

### 2. CallerRunsPolicy 示例

```java
import java.util.concurrent.*;

public class CallerRunsPolicyDemo {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2, 2, 0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(2),
                new ThreadPoolExecutor.CallerRunsPolicy()); // 由调用线程执行

        System.out.println("主线程: " + Thread.currentThread().getName());

        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            executor.execute(() -> {
                try {
                    System.out.println("执行任务" + taskId + " 线程: " +
                            Thread.currentThread().getName());
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
            System.out.println("提交任务" + taskId);
        }

        executor.shutdown();
    }
}
```

**输出特点**：第 5 个任务会由主线程(main)执行

### 3. DiscardPolicy 示例

```java
import java.util.concurrent.*;

public class DiscardPolicyDemo {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2, 2, 0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(2),
                new ThreadPoolExecutor.DiscardPolicy()); // 静默丢弃

        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            executor.execute(() -> {
                try {
                    System.out.println("执行任务" + taskId + " 线程: " +
                            Thread.currentThread().getName());
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
            System.out.println("提交任务" + taskId);
        }

        executor.shutdown();
    }
}
```

**输出特点**：第 5 个任务被静默丢弃，无任何提示

### 4. DiscardOldestPolicy 示例

```java
import java.util.concurrent.*;

public class DiscardOldestPolicyDemo {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2, 2, 0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(2),
                new ThreadPoolExecutor.DiscardOldestPolicy()); // 丢弃最旧任务

        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            executor.execute(() -> {
                try {
                    System.out.println("执行任务" + taskId + " 线程: " +
                            Thread.currentThread().getName());
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
            System.out.println("提交任务" + taskId);
        }

        executor.shutdown();
    }
}
```

**输出特点**：第 5 个任务会替换掉队列中最早的任务(第 3 个)

### 对比总结

| 策略                | 行为             | 异常抛出                        | 适用场景               |
| ------------------- | ---------------- | ------------------------------- | ---------------------- |
| AbortPolicy         | 直接拒绝新任务   | 抛出 RejectedExecutionException | 需要明确知道任务被拒绝 |
| CallerRunsPolicy    | 由调用线程执行   | 不抛出异常                      | 不允许任务丢失         |
| DiscardPolicy       | 静默丢弃新任务   | 不抛出异常                      | 允许静默丢失           |
| DiscardOldestPolicy | 丢弃队列最旧任务 | 不抛出异常                      | 新任务比旧任务重要     |

所有示例都使用相同的线程池配置：

- 核心线程数：2
- 最大线程数：2
- 队列容量：2
- 因此最大可接受任务数=2(执行中)+2(队列中)=4
- 第 5 个任务会触发拒绝策略

## 接受线程的返回值

```java
public class ModifiedMultiThreadExample {
    private static final Random random = new Random();

    public static void main(String[] args) {
        ExecutorService syncExecutor = Executors.newFixedThreadPool(10);
        List<Future<Integer>> futures = new ArrayList<>();

        for (int i = 0; i < 50; i++) {
            final int taskId = i;
            Future<Integer> result = syncExecutor.submit(() -> {
                // 随机sleep时间(0-2秒)
                int sleepTime = random.nextInt(2000);
                Thread.sleep(sleepTime);

                System.out.println("task" + taskId + " 执行完成，耗时 " + sleepTime + "ms");

                // 模拟部分任务失败（大约20%的概率）
                if (random.nextDouble() < 0.2) {
                    throw new RuntimeException("task" + taskId + " 模拟异常");
                }

                return taskId * 5;
            });
            futures.add(result);
        }

        // 处理结果
        for (Future<Integer> future : futures) {
            try {
                // 这里会抛出异常，如果任务执行时抛出了异常
                Integer result = future.get();
                System.out.println("成功获取结果: " + result);
            } catch (InterruptedException e) {
                System.err.println("任务被中断: " + e.getMessage());
            } catch (ExecutionException e) {
                System.err.println("任务执行异常: " + e.getCause().getMessage());
            }
        }

        syncExecutor.shutdown();
    }
}
```

### futures 获取的值是否和 syncExecutor.submit 添加线程的顺序保持一致吗

`List<Future<Integer>> futures` 中的结果顺序与 `syncExecutor.submit()` 添加任务的顺序是一致的

```java
public class ExtremeDisorderValidation {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(10); // 足够大的线程池
        List<Future<Integer>> futures = new ArrayList<>();

        // 创建任务并故意设置极不均衡的执行时间
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            // 让执行时间从后往前递增（确保先提交的任务最后完成）
            int sleepTime = (9 - i) * 500; // 任务0睡眠4500ms，任务9睡眠0ms
            Future<Integer> future = executor.submit(() -> {
                System.out.printf("任务%d 开始执行，将睡眠%dms%n", taskId, sleepTime);
                Thread.sleep(sleepTime);
                System.out.printf("任务%d 完成%n", taskId);
                return taskId;
            });
            futures.add(future);
            System.out.printf("已提交任务%d (设置睡眠%dms)%n", taskId, sleepTime);
        }

        // 按提交顺序获取结果（应该与完成顺序完全相反）
        System.out.println("\\\\n按提交顺序获取结果:");
        for (int i = 0; i < futures.size(); i++) {
            try {
                long start = System.currentTimeMillis();
                int result = futures.get(i).get();
                long duration = System.currentTimeMillis() - start;
                System.out.printf("futures[%d] -> 任务%d (获取耗时%dms)%n", i, result, duration);
            } catch (Exception e) {
                System.out.println("获取异常: " + e.getMessage());
            }
        }

        executor.shutdown();
    }
}
```

### CompletableFuture 使用 demo

CompletableFuture 和 futures 都能保证 获取的值是否和 syncExecutor.submit 添加线程的顺序保持一致

```java
public class CompletableFutureWithFailures {
    private static final Random random = new Random();

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        List<CompletableFuture<Integer>> futures = new ArrayList<>();

        // 创建任务并设置不均衡的执行时间和随机失败
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            int sleepTime = (9 - i) * 500; // 任务0睡眠4500ms，任务9睡眠0ms

            CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
                System.out.printf("任务%d 开始执行，将睡眠%dms%n", taskId, sleepTime);
                try {
                    Thread.sleep(sleepTime);

                    // 模拟30%概率失败
                    if (random.nextDouble() < 0.3) {
                        throw new RuntimeException("任务" + taskId + " 模拟执行失败");
                    }

                    System.out.printf("任务%d 成功完成%n", taskId);
                    return taskId;
                } catch (InterruptedException e) {
                    throw new RuntimeException("任务" + taskId + " 被中断");
                }
            }, executor);

            futures.add(future);
            System.out.printf("已提交任务%d (设置睡眠%dms)%n", taskId, sleepTime);
        }

        // 按提交顺序获取结果
        System.out.println("\\\\n按提交顺序获取结果:");
        for (int i = 0; i < futures.size(); i++) {
            try {
                long start = System.currentTimeMillis();
                int result = futures.get(i).join();
                long duration = System.currentTimeMillis() - start;
                System.out.printf("futures[%d] -> 任务%d (获取耗时%dms)%n", i, result, duration);
            } catch (CompletionException e) {
                System.out.printf("futures[%d] -> 异常: %s%n",
                    i, e.getCause().getMessage());
            }
        }

        executor.shutdown();
    }
}
```

#### CompletableFuture 使用常用方法

#### runAsync 和 supplyAsync 的区别

1. runAsync 执行 Runnable (无返回值)
2. supplyAsync 执行 Supplier (有返回值)

```java
CompletableFuture.runAsync(() -> {
    System.out.println("执行无返回值的异步任务");
    // 模拟耗时操作
    try { Thread.sleep(1000); } catch (InterruptedException e) {}
}).thenRun(() -> System.out.println("任务完成")).join();
// 执行无返回值的异步任务
// 任务完成

CompletableFuture.supplyAsync(() -> {
    System.out.println("执行有返回值的异步任务");
    // 模拟耗时操作
    try { Thread.sleep(1000); } catch (InterruptedException e) {}
    return "任务结果";
}).thenAccept(result -> System.out.println("获取到结果: " + result)).join();
// 执行有返回值的异步任务
// 获取到结果: 任务结果
```

#### get 和 join 的区别

get() 和 join() 都是用于获取 CompletableFuture 结果的方法 但是使用 get() 方法，需要声明或者抛出异常， join() 不需要强制对异常进行处理，但是也有抛出异常的可能

#### thenApply, thenAccept, thenRun 使用的 demo

```java
CompletableFuture.supplyAsync(() -> 10)
    .thenApply(num -> num * 2)      // 20
    .thenAccept(n -> System.out.println("Value: " + n))  // 输出
    .thenRun(() -> System.out.println("Calculation completed"));

/* Value: 20
Calculation completed */
```

#### exceptionally, handle 使用的 demo

1. `exceptionally` 演示结果（异常恢复）

```java
CompletableFuture.supplyAsync(() -> {
        if (true) throw new RuntimeException("error");
        return "success";
    })
    .exceptionally(ex -> {
        return "fallback";
    })
    .thenAccept(System.out::println);

CompletableFuture.supplyAsync(() -> {
        throw new RuntimeException("error");
    })
    .thenApply(s -> s + " processed")  // 跳过
    .thenAccept(System.out::println)  // 跳过
    .exceptionally(ex -> {
        System.out.println("Error: " + ex.getMessage());
        return null;
    });
```

**输出结果**：

```
fallback
```

1. `handle` 演示结果（统一处理成功/失败）

```java
CompletableFuture.supplyAsync(() -> {
        if (Math.random() > 0.5) throw new RuntimeException("error");
        return "success";
    })
    .handle((res, ex) -> {
        if (ex != null) return "handled error";
        return "handled: " + res;
    })
    .thenAccept(System.out::println);
```

**可能输出结果**：

```
handled: success
或
handled error
```

#### 组合多个 Future 使用的 demo

1. **`allOf`** 用于等待所有任务完成，但不聚合结果
2. **`anyOf`** 用于获取最先完成的任务结果
3. **`thenCombine`** 合并两个独立任务的结果
4. **`thenCompose`** 用于链式依赖的任务

```java
        // 创建3个异步任务
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            try { Thread.sleep(1000); } catch (InterruptedException e) {}
            return "结果1";
        });

        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            try { Thread.sleep(1500); } catch (InterruptedException e) {}
            return "结果2";
        });

        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {
            try { Thread.sleep(800); } catch (InterruptedException e) {}
            return "结果3";
        });

        // 等待所有任务完成
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(future1, future2, future3);
        // 获取所有结果
        allFutures.thenRun(() -> {
            try {
                String result1 = future1.get();
                String result2 = future2.get();
                String result3 = future3.get();
                System.out.println("所有结果: " + result1 + ", " + result2 + ", " + result3);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).join();
        // 输出: 所有结果: 结果1, 结果2, 结果3

        CompletableFuture<Object> anyResult = CompletableFuture.anyOf(future1, future2, future3);
        // 获取最先完成的结果
        anyResult.thenAccept(result -> {
            System.out.println("最先完成的结果: " + result);
        }).join();
        // 输出: 最先完成的结果: 结果1

        // 组合多个任务结果
        CompletableFuture<String> combinedFuture = future1.thenCombine(future2, (res1, res2) -> res1 + " 和 " + res2 + " 已合并");
        System.out.println(combinedFuture.join()); // 输出: 结果1 和 结果2 已合并

        // 链式依赖组合
        CompletableFuture<Integer> userIdFuture = CompletableFuture.supplyAsync(() -> 123);
        CompletableFuture<String> userDetailFuture = userIdFuture.thenCompose(userId ->
            CompletableFuture.supplyAsync(() -> "用户" + userId + "的详情")
        );
        System.out.println(userDetailFuture.join()); // 输出: 用户123的详情
```

#### allOf 获取有异常情况的返回集合

```java
    private static final Random random = new Random();

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        List<CompletableFuture<Integer>> futures = new ArrayList<>();

        // 提交50个异步任务
        for (int i = 0; i < 50; i++) {
            final int taskId = i;
            CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
                // 随机sleep时间(0-2秒)
                int sleepTime = random.nextInt(2000);
                try {
                    Thread.sleep(sleepTime);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }

                System.out.println("task" + taskId + " 执行完成，耗时 " + sleepTime + "ms");

                // 模拟部分任务失败（大约20%的概率）
                if (random.nextDouble() < 0.2) {
                    throw new RuntimeException("task" + taskId + " 模拟异常");
                }

                return taskId;
            }, executor);

            futures.add(future);
        }

        /**
         * CompletableFuture.allOf 报错会卡死， 因为内部线程传递出异常没有处理
         */
        /* CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .whenComplete((result, ex) -> {
                System.out.println("\\\\n所有任务已完成，开始处理结果:");

                for (int i = 0; i < futures.size(); i++) {
                    int finalI = i;
                    futures.get(i)
                        .thenAccept(r -> System.out.println("任务" + finalI + " 结果: " + r))
                        .exceptionally(e -> {
                            System.err.println("任务" + finalI + " 失败: " + e.getCause().getMessage());
                            return null;
                        });
                }
            })
            .join(); */

        /**
         * 等所有的任务执行完毕后，一口气打印所有的结果，没有卡顿
         */
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .whenComplete((result, ex) -> {
                System.out.println("\\\\n所有任务已完成，开始处理结果:");

                for (int i = 0; i < futures.size(); i++) {
                    int finalI = i;
                    futures.get(i)
                        .thenAccept(r -> System.out.println("任务" + finalI + " 结果: " + r))
                        .exceptionally(e -> {
                            System.err.println("任务" + finalI + " 失败: " + e.getCause().getMessage());
                            return null;
                        });
                }
            })
            .exceptionally(ex -> {
                System.out.println("所有线程抛出的第一个异常被接受到了" + ex.getMessage());
                return null;
            }).join();
        /**
         * 按照线程添加的顺序打印，输出会卡顿，根据线程大小同时执行的线程数量不同，一次性打印的结果数量也不同，有卡顿
         */
        /* System.out.println("\\\\n任务边执行边输出，开始处理结果:");
        for (int i = 0; i < futures.size(); i++) {
            int finalI = i;
            futures.get(i)
                .thenAccept(r -> System.out.println("任务" + finalI + " 结果: " + r))
                .exceptionally(e -> {
                    System.err.println("任务" + finalI + " 失败: " + e.getCause().getMessage());
                    return null;
                });
        } */

        executor.shutdown();
    }
```

#### allOf 最终还是要通过遍历 futures 获取 join 的返回值，那么为什么不直接使用遍历 futures 获取 join 的返回值，allOf 的作用是什么

1. 统一获取所有线程直线完毕的消耗的时间
2. 统一获取所有线程是否有全部执行成功，因为如果有一个线程抛出异常，这个异常就会被传递出来，影响到 allOf 的 join

#### orTimeout, completeOnTimeout 使用的 demo

orTimeout 和 completeOnTimeOut 是 java9 的方法，暂时不考虑

#### whenComplete 和 whenCompleteAsync 有什么区别

1. whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。
2. whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。

```java
        CompletableFuture.supplyAsync(() -> {
            System.out.println("1.执行线程: " + Thread.currentThread().getName());
            return "结果";
        }).whenComplete((res, ex) -> {
            System.out.println("1.回调线程: " + Thread.currentThread().getName());
        });
        // 1.执行线程: ForkJoinPool.commonPool-worker-25
        // 1.回调线程: main

        CompletableFuture.supplyAsync(() -> {
            System.out.println("2.执行线程: " + Thread.currentThread().getName());
            return "结果";
        }).whenCompleteAsync((res, ex) -> {
            System.out.println("2.回调线程: " + Thread.currentThread().getName());
        });
        // 2.执行线程: ForkJoinPool.commonPool-worker-25
        // 2.回调线程: ForkJoinPool.commonPool-worker-25
```

#### whenComplete 和 thenAccept 有什么区别

1. whenComplete 能处理异常，thenAccept 不能处理异常

2. whenComplete 不会修改链式传递的结果，能处理异常，thenAccept 会修改链式传递的结果

   ```java
    CompletableFuture<String> original = CompletableFuture.completedFuture("hello");
    CompletableFuture<String> after = original.whenComplete((r,e) -> {});
    // original == after
   
    CompletableFuture<String> original = ...;
    CompletableFuture<Void> after = original.thenAccept(r -> {});
    // 类型从 CompletableFuture<String> 变为 CompletableFuture<Void>
   ```

3. whenComplete 不会吞掉异常，thenAccept 需要单独使用 exceptionally 处理异常

4. whenComplete 使用的场景一般是 日志记录，thenAccept 使用的场景一般是 结果消费

## 多线程超时关闭的 demo

```java
public class GracefulShutdownDemo {

    // 原子计数器
    private static final AtomicInteger successCount = new AtomicInteger(0);

    private static final AtomicInteger interruptCount = new AtomicInteger(0);

    private static final AtomicInteger queueCancelCount = new AtomicInteger(0);

    private static final AtomicInteger rejectCount = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        // 1. 配置线程池（核心2，最大3，队列5）
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 3, 0, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(5),
            new ThreadPoolExecutor.AbortPolicy()
        );

        // 2. 提交混合任务（包含不同耗时）
        submitTasks(executor);

        // 3. 等待部分任务进入执行和队列
        TimeUnit.SECONDS.sleep(2);

        // 4. 执行分级关闭
        shutdownGracefully(executor);

        // 5. 打印统计结果
        System.out.println("\\\\n==== 执行结果 ====");
        System.out.println("成功完成: " + successCount.get());
        System.out.println("被中断的: " + interruptCount.get());
        System.out.println("队列取消: " + queueCancelCount.get());
        System.out.println("被拒绝的: " + rejectCount.get());
    }

    private static void submitTasks(ThreadPoolExecutor executor) {
        // 任务1-2（快速任务，1秒完成）
        submitFastTask(executor, 1, 1);
        submitFastTask(executor, 2, 1);

        // 任务3-4（慢速任务，5秒完成）
        submitSlowTask(executor, 3, 5);
        submitSlowTask(executor, 4, 5);
        submitSlowTask(executor, 5, 5);
        submitSlowTask(executor, 6, 5);
        submitSlowTask(executor, 7, 5);
        submitSlowTask(executor, 8, 5);

        // 任务5（将被拒绝）
        try {
            executor.submit(() -> {
                System.out.println("任务9执行（实际不会执行）");
                return null;
            });
        } catch (RejectedExecutionException e) {
            System.err.println("任务9被拒绝");
            rejectCount.incrementAndGet();
        }
    }

    private static void submitFastTask(ThreadPoolExecutor executor, int taskId, int seconds) {
        executor.submit(() -> {
            try {
                System.out.printf("[%tT] 任务%d（快速）开始%n", System.currentTimeMillis(), taskId);
                TimeUnit.SECONDS.sleep(seconds);
                successCount.incrementAndGet();
                System.out.printf("[%tT] 任务%d（快速）完成%n", System.currentTimeMillis(), taskId);
                return null;
            } catch (InterruptedException e) {
                interruptCount.incrementAndGet();
                System.out.printf("[%tT] 任务%d（快速）被中断%n", System.currentTimeMillis(), taskId);
                return null;
            }
        });
    }

    private static void submitSlowTask(ThreadPoolExecutor executor, int taskId, int seconds) {
        executor.submit(() -> {
            try {
                System.out.printf("[%tT] 任务%d（慢速）开始%n", System.currentTimeMillis(), taskId);
                TimeUnit.SECONDS.sleep(seconds);
                successCount.incrementAndGet();
                System.out.printf("[%tT] 任务%d（慢速）完成%n", System.currentTimeMillis(), taskId);
                return null;
            } catch (InterruptedException e) {
                interruptCount.incrementAndGet();
                System.out.printf("[%tT] 任务%d（慢速）被中断%n", System.currentTimeMillis(), taskId);
                return null;
            }
        });
    }

    private static void shutdownGracefully(ThreadPoolExecutor executor) {
        System.out.printf("%n[%tT] 开始关闭线程池%n", System.currentTimeMillis());
        // 第一阶段：温和关闭
        executor.shutdown();

        try {
            // 等待3秒（足够快速任务完成，但不够慢速任务完成）
            if (!executor.awaitTermination(3, TimeUnit.SECONDS)) {
                System.out.printf("[%tT] 第一阶段等待超时，剩余任务数: %d%n",
                    System.currentTimeMillis(), executor.getActiveCount());

                // 第二阶段：强制关闭
                List<Runnable> cancelled = executor.shutdownNow();
                queueCancelCount.addAndGet(cancelled.size());
                System.out.printf("[%tT] 强制取消队列任务: %d%n",
                    System.currentTimeMillis(), cancelled.size());

                // 最后等待
                if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {
                    System.out.println("仍有线程未退出");
                }
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
    /**
     * 任务9被拒绝
     * [16:05:09] 任务1（快速）开始
     * [16:05:09] 任务8（慢速）开始
     * [16:05:09] 任务2（快速）开始
     * [16:05:10] 任务1（快速）完成
     * [16:05:10] 任务2（快速）完成
     * [16:05:10] 任务4（慢速）开始
     * [16:05:10] 任务3（慢速）开始
     *
     * [16:05:11] 开始关闭线程池
     * [16:05:14] 第一阶段等待超时，剩余任务数: 3
     * [16:05:14] 任务3（慢速）被中断
     * [16:05:14] 强制取消队列任务: 3
     * [16:05:14] 任务8（慢速）被中断
     * [16:05:14] 任务4（慢速）被中断
     *
     * ==== 执行结果 ====
     * 成功完成: 2
     * 被中断的: 3
     * 队列取消: 3
     * 被拒绝的: 1
     */
}
```

### 常用的方法

1. **`Thread.currentThread().interrupt()`** 有什么用 当线程被中断时（通过 interrupt() 方法），会设置一个中断标志位 但如果线程在阻塞状态（如 sleep()、wait()、join()）时被中断，会抛出 InterruptedException 并清除中断状态 调用 Thread.currentThread().interrupt() 可以重新设置中断状态 **为什么需要它？** 当捕获 InterruptedException 时，中断状态会被清除。如果不恢复中断状态会导致：

   1. 上层调用方无法检测到中断请求
   2. 线程池无法正确判断任务是否被中断
   3. 可能导致程序无法正常终止

2. **`Thread.interrupted()`** 有什么用

   `Thread.interrupted()` 是 Java 多线程编程中用于**检查并清除当前线程中断状态**的静态方法。它的核心特性和使用场景如下：

   **核心作用**

   1. **检查中断状态** 判断当前线程是否被中断（即 `interrupt()` 是否被调用过）
   2. **清除中断状态** 调用后会**自动重置**中断状态为 `false`（与 `isInterrupted()` 的关键区别）

   **与相似方法的对比**

   | 方法                     | 作用      | 是否清除中断状态 | 调用对象 |
   | ------------------------ | --------- | ---------------- | -------- |
   | `Thread.interrupted()`   | 检查+清除 | ✅ 是             | 当前线程 |
   | `thread.isInterrupted()` | 仅检查    | ❌ 否             | 指定线程 |
   | `thread.interrupt()`     | 设置中断  | ❌ 否             | 指定线程 |

### shutdown 和 shutdownNow 是否不能真正的关闭线程，还是需要线程内部抛出 InterruptedException 异常，才能正在关闭线程

1. shutdown 仅不再接受新任务，已提交的任务会继续执行直到完成
2. shutdownNow 立即停止接受新任务，向所有工作线程发送 interrupt() 信号，但实际中断效果取决于任务代码

**结论：** *shutdownNow() 的强制关闭能力完全依赖于任务代码对中断的响应，没有代码配合的线程确实无法被真正关闭。这是 Java"协作式中断"设计理念的体现*

### 是否可以通过抛出异常的方式，达到 Thread.currentThread().interrupt()中断线程的效果

不可以，因为抛出普通异常不会设置线程的中断标志，导致：

- 线程池无法感知任务被取消
- `Future.cancel(true)` 等操作失效
- 无法通过 `isInterrupted()` 检测中断请求

**如何结合两者实现最佳效果？**

```java
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // 先恢复中断状态
    throw new RuntimeException("任务被中断", e); // 再抛异常
}
```

**总结**

- **直接抛异常 ≠ 中断线程**：异常只终止当前执行流，不维护中断状态
- **必须配合 `interrupt()`**：如需抛异常，必须先调用 `Thread.currentThread().interrupt()`
- **设计原则**：保持中断信号的传递链，这是 Java 并发编程的基础规范

### 关闭线程池使用 shutdownNow() 方法， `Thread.currentThread().isInterrupted()` 的使用场景是什么

1. 当线程执行一个非阻塞的循环任务（例如计算密集型操作），且没有调用任何会抛出 InterruptedException 的方法（如 sleep()、wait()、join()）时，中断信号不会自动触发终止。此时必须通过 isInterrupted() 主动检查中断标志，决定是否退出循环
2. 如果线程需要根据中断状态执行特定的清理逻辑（如回滚操作、关闭连接等），而不是直接抛出异常时

### 如何在线程外，例如主线程上，设置线程的中断状态

1. 如果能获取到需要中断的线程，可以通过线程调用 `interrupt()` 方法中断
2. 若通过线程池（如 `ExecutorService`）提交任务，主线程可通过 `Future.cancel(true)` 中断任务

## 参看链接

- https://blog.csdn.net/July_whj/article/details/120570180